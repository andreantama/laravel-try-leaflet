(function() {
  "use strict";
  try {
    if (typeof document != "undefined") {
      var elementStyle = document.createElement("style");
      elementStyle.appendChild(document.createTextNode(".leaflet-pane.leaflet-lhl-raised-pane {\n	z-index: 620;\n}\n\n.leaflet-pane.leaflet-lhl-almost-over-pane {\n	z-index: 201;\n}"));
      document.head.appendChild(elementStyle);
    }
  } catch (e) {
    console.error("vite-plugin-css-injected-by-js", e);
  }
})();
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import { Map, Util, Circle, CircleMarker, Polygon, Polyline, Rectangle } from "leaflet";
Map.addInitHook(function() {
  this.createPane("lhl-raised");
  this.createPane("lhl-almost-over");
});
function setLayerPane(layer, pane) {
  if (layer.options.pane == pane)
    return;
  layer.options.pane = pane;
  if (layer["_map"])
    layer["_map"].removeLayer(layer).addLayer(layer);
}
function setLayerRenderer(layer, renderer) {
  if (layer.options.renderer == renderer)
    return;
  layer.options.renderer = renderer;
  if (layer._renderer) {
    if (renderer["_map"] && layer["_path"]) {
      layer._renderer._removePath(layer);
    }
    layer._renderer = renderer;
    layer._renderer._layers[Util.stamp(layer)] = layer;
    layer._renderer._updateStyle(layer);
    if (renderer["_map"] && layer["_path"]) {
      layer._renderer._addPath(layer);
    }
  }
}
const BRIGHT_OUTLINE_COLOR = "#000000";
const DARK_OUTLINE_COLOR = "#ffffff";
const BRIGHT_OUTLINE_WEIGHT_REDUCTION_FACTOR = 1.6;
const OUTLINE_WEIGHT_FACTOR = 2;
const POLYLINE_MIN_INTERACTION_WIDTH = 20;
function getBrightness(colour) {
  const c = colour.replace(/^#/, "");
  const r = parseInt(c.substr(0, 2), 16) / 255;
  const g = parseInt(c.substr(2, 2), 16) / 255;
  const b = parseInt(c.substr(4, 2), 16) / 255;
  return Math.sqrt(0.241 * r * r + 0.691 * g * g + 0.068 * b * b);
}
function isBright(color) {
  return getBrightness(color) > 0.7;
}
function clone(obj) {
  return Object.assign(Object.create(Object.getPrototypeOf(obj)), obj);
}
function generatePolygonStyles(options, renderer) {
  const bright = isBright(options.color);
  const outlineColor = options.outlineColor ?? (bright ? BRIGHT_OUTLINE_COLOR : DARK_OUTLINE_COLOR);
  const lineWeight = options.outlineColor == null && options.outlineWeight == null && bright ? Math.round(options.weight / BRIGHT_OUTLINE_WEIGHT_REDUCTION_FACTOR) : options.weight;
  const outlineWeight = options.outlineWeight ?? lineWeight * OUTLINE_WEIGHT_FACTOR;
  return {
    main: {
      ...options,
      renderer,
      weight: outlineWeight,
      opacity: 0,
      dashArray: void 0,
      dashOffset: void 0
    },
    fill: {
      ...options,
      renderer,
      stroke: false
    },
    outline: {
      ...options,
      color: outlineColor,
      weight: outlineWeight,
      renderer,
      fill: false
    },
    border: {
      ...options,
      weight: lineWeight,
      renderer,
      fill: false
    }
  };
}
function generatePolylineStyles(options, renderer) {
  const isBright2 = getBrightness(options.color.replace(/^#/, "")) > 0.7;
  const outlineColor = options.outlineColor ?? (isBright2 ? "#000000" : "#ffffff");
  const lineWeight = options.outlineColor == null && options.outlineWeight == null && isBright2 ? Math.round(options.weight / 1.6) : options.weight;
  const outlineWeight = options.outlineWeight ?? lineWeight * 2;
  return {
    outline: {
      ...options,
      color: outlineColor,
      weight: outlineWeight,
      renderer
    },
    line: {
      ...options,
      weight: lineWeight,
      renderer
    },
    main: {
      opacity: 0,
      weight: Math.max(POLYLINE_MIN_INTERACTION_WIDTH, outlineWeight, lineWeight),
      pane: "lhl-almost-over",
      dashArray: void 0,
      dashOffset: void 0
    }
  };
}
function createHighlightableLayerClass(BaseClass, createLayer, cloneMethods = [], defaultOptions) {
  const result = class HighlightableLayer extends BaseClass {
    constructor(...args) {
      super(...args);
      __publicField(this, "realOptions");
      __publicField(this, "layers", {});
      __publicField(this, "_isAdding", false);
      this.realOptions = Object.assign(Object.create(Object.getPrototypeOf(this.options)), {
        generateStyles: generatePolygonStyles,
        ...defaultOptions,
        ...this.options
      });
    }
    beforeAdd(map) {
      const renderer = map._createRenderer();
      this._updateStyle(renderer);
      this._renderer = renderer;
      renderer.once("add", () => {
        renderer._container.style.opacity = `${this.realOptions.opacity ?? 1}`;
      });
      map.addLayer(renderer);
      return this;
    }
    onAdd(map) {
      super.onAdd(map);
      for (const layerName of Object.keys(this.layers)) {
        map.addLayer(this.layers[layerName]);
      }
      return this;
    }
    onRemove(map) {
      for (const layerName of Object.keys(this.layers)) {
        map.removeLayer(this.layers[layerName]);
      }
      super.onRemove(map);
      map.removeLayer(this._renderer);
      delete this._renderer;
      return this;
    }
    _updateStyle(renderer) {
      var _a, _b;
      renderer.options.pane = this.realOptions.raised ? "lhl-raised" : this.realOptions.pane;
      if (renderer._container)
        renderer.getPane().appendChild(renderer._container);
      const styles = ((_b = (_a = this.realOptions).generateStyles) == null ? void 0 : _b.call(_a, Object.assign(clone(this.realOptions), { opacity: 1 }), renderer)) ?? { main: clone(this.realOptions) };
      for (const layerName of Object.keys(this.layers)) {
        if (!Object.prototype.hasOwnProperty.call(styles, layerName)) {
          if (this._map) {
            this._map.removeLayer(this.layers[layerName]);
          }
          delete this.layers[layerName];
        }
      }
      for (const layerName of Object.keys(styles)) {
        if (layerName !== "main") {
          if (!this.layers[layerName]) {
            this.layers[layerName] = createLayer(this);
            this.layers[layerName].options.interactive = false;
            if (BaseClass === Polyline || BaseClass.prototype instanceof Polyline) {
              this.layers[layerName]._updateBounds = function() {
                if (this._rawPxBounds)
                  BaseClass.prototype._updateBounds.call(this);
              };
            }
          }
        }
      }
      if (styles.main.pane)
        setLayerPane(this, styles.main.pane);
      if (styles.main.renderer)
        setLayerRenderer(this, styles.main.renderer);
      super.setStyle(styles.main);
      for (const layerName of Object.keys(this.layers)) {
        if (styles[layerName].pane)
          setLayerPane(this.layers[layerName], styles[layerName].pane);
        if (styles[layerName].renderer)
          setLayerRenderer(this.layers[layerName], styles[layerName].renderer);
        this.layers[layerName].setStyle(styles[layerName]);
      }
      if (renderer._container)
        renderer._container.style.opacity = `${this.realOptions.opacity ?? 1}`;
      if (this._map) {
        for (const layer of Object.values(this.layers)) {
          if (!layer["_map"]) {
            this._map.addLayer(layer);
          }
        }
      }
    }
    setStyle(style) {
      Object.assign(this.realOptions, style);
      if (this._renderer) {
        this._updateStyle(this._renderer);
      }
      return this;
    }
    _updateBounds() {
      if (!(this instanceof Polyline) || this._rawPxBounds)
        super._updateBounds();
    }
  };
  for (const method of ["redraw", ...cloneMethods]) {
    result.prototype[method] = function(...args) {
      const r = Object.getPrototypeOf(result.prototype)[method].apply(this, args);
      for (const layerName of Object.keys(this.layers)) {
        this.layers[layerName][method].apply(this.layers[layerName], args);
      }
      return r;
    };
  }
  return result;
}
const HighlightableCircle = createHighlightableLayerClass(
  Circle,
  (mainLayer) => new Circle(mainLayer.getLatLng(), mainLayer.getRadius()),
  ["setRadius", "setLatLng"]
);
const HighlightableCircleMarker = createHighlightableLayerClass(
  CircleMarker,
  (mainLayer) => new CircleMarker(mainLayer.getLatLng(), { radius: mainLayer.getRadius() }),
  ["setRadius", "setLatLng"]
);
const HighlightablePolygon = createHighlightableLayerClass(
  Polygon,
  (mainLayer) => new Polygon(mainLayer.getLatLngs()),
  ["setLatLngs"]
);
const HighlightablePolyline = createHighlightableLayerClass(
  Polyline,
  (mainLayer) => new Polyline(mainLayer.getLatLngs()),
  ["setLatLngs"],
  {
    generateStyles: generatePolylineStyles
  }
);
const HighlightableRectangle = createHighlightableLayerClass(
  Rectangle,
  (mainLayer) => new Rectangle(mainLayer.getBounds()),
  ["setBounds"]
);
export {
  BRIGHT_OUTLINE_COLOR,
  BRIGHT_OUTLINE_WEIGHT_REDUCTION_FACTOR,
  DARK_OUTLINE_COLOR,
  HighlightableCircle,
  HighlightableCircleMarker,
  HighlightablePolygon,
  HighlightablePolyline,
  HighlightableRectangle,
  OUTLINE_WEIGHT_FACTOR,
  POLYLINE_MIN_INTERACTION_WIDTH,
  clone,
  createHighlightableLayerClass,
  generatePolygonStyles,
  generatePolylineStyles,
  getBrightness,
  isBright,
  setLayerPane,
  setLayerRenderer
};
//# sourceMappingURL=L.HighlightableLayers.js.map
