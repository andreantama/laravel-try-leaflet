{"version":3,"file":"L.HighlightableLayers.js","sources":["../src/panes.ts","../src/utils.ts","../src/styles.ts","../src/layers.ts"],"sourcesContent":["import { Layer, Map, Path, Renderer, Util } from \"leaflet\";\nimport \"./panes.css\";\n\nMap.addInitHook(function (this: Map) {\n\tthis.createPane(\"lhl-raised\");\n\tthis.createPane(\"lhl-almost-over\");\n});\n\nexport function setLayerPane(layer: Layer, pane: string) {\n\tif(layer.options.pane == pane)\n\t\treturn;\n\n\tlayer.options.pane = pane;\n\n\tif(layer[\"_map\"])\n\t\tlayer[\"_map\"].removeLayer(layer).addLayer(layer);\n}\n\nexport function setLayerRenderer(layer: Path, renderer: Renderer) {\n\tif(layer.options.renderer == renderer)\n\t\treturn;\n\n\tlayer.options.renderer = renderer;\n\n\tif (layer._renderer) {\n\t\t// Like layer.onRemove() and layer.onAdd(), but we don't want to really remove and add the layer (to avoid an infinite loop)\n\t\tif (renderer[\"_map\"] && layer[\"_path\"]) {\n\t\t\tlayer._renderer._removePath(layer);\n\t\t}\n\n\t\tlayer._renderer = renderer;\n\t\tlayer._renderer._layers[Util.stamp(layer)] = layer;\n\t\tlayer._renderer._updateStyle(layer);\n\t\tif (renderer[\"_map\"] && layer[\"_path\"]) {\n\t\t\tlayer._renderer._addPath(layer);\n\t\t}\n\t}\n}","export const BRIGHT_OUTLINE_COLOR = \"#000000\";\nexport const DARK_OUTLINE_COLOR = \"#ffffff\";\nexport const BRIGHT_OUTLINE_WEIGHT_REDUCTION_FACTOR = 1.6;\nexport const OUTLINE_WEIGHT_FACTOR = 2;\nexport const POLYLINE_MIN_INTERACTION_WIDTH = 20;\n\nexport function getBrightness(colour: string): number {\n\tconst c = colour.replace(/^#/, \"\");\n\tconst r = parseInt(c.substr(0, 2), 16)/255;\n\tconst g = parseInt(c.substr(2, 2), 16)/255;\n\tconst b = parseInt(c.substr(4, 2), 16)/255;\n\t// See http://stackoverflow.com/a/596243/242365\n\treturn Math.sqrt(0.241*r*r + 0.691*g*g + 0.068*b*b);\n}\n\nexport function isBright(color: string): boolean {\n\treturn getBrightness(color) > 0.7;\n}\n\nexport function clone<T>(obj: T): T {\n\t// See https://stackoverflow.com/a/44782052/242365\n\treturn Object.assign(Object.create(Object.getPrototypeOf(obj)), obj);\n}","import { PathOptions, Renderer } from \"leaflet\";\nimport { HighlightableLayerOptions } from \"./layers\";\nimport { BRIGHT_OUTLINE_COLOR, BRIGHT_OUTLINE_WEIGHT_REDUCTION_FACTOR, DARK_OUTLINE_COLOR, OUTLINE_WEIGHT_FACTOR, POLYLINE_MIN_INTERACTION_WIDTH, getBrightness, isBright } from \"./utils\";\n\nexport function generatePolygonStyles(options: HighlightableLayerOptions<PathOptions>, renderer: Renderer): Record<string, PathOptions> {\n\tconst bright = isBright(options.color!);\n\tconst outlineColor = options.outlineColor ?? (\n\t\tbright ? BRIGHT_OUTLINE_COLOR : DARK_OUTLINE_COLOR\n\t);\n\n\t// A black outline makes the lines look thicker, thus we decrease the thickness to make them look the original size again.\n\t// If the user has specified a custom look for the outline, let's not do any magic.\n\tconst lineWeight = (options.outlineColor == null && options.outlineWeight == null && bright) ? Math.round(options.weight! / BRIGHT_OUTLINE_WEIGHT_REDUCTION_FACTOR) : options.weight!;\n\n\tconst outlineWeight = options.outlineWeight ?? (lineWeight * OUTLINE_WEIGHT_FACTOR);\n\n\treturn {\n\t\tmain: {\n\t\t\t...options,\n\t\t\trenderer,\n\t\t\tweight: outlineWeight,\n\t\t\topacity: 0,\n\t\t\tdashArray: undefined,\n\t\t\tdashOffset: undefined\n\t\t},\n\n\t\tfill: {\n\t\t\t...options,\n\t\t\trenderer,\n\t\t\tstroke: false\n\t\t},\n\n\t\toutline: {\n\t\t\t...options,\n\t\t\tcolor: outlineColor,\n\t\t\tweight: outlineWeight,\n\t\t\trenderer,\n\t\t\tfill: false\n\t\t},\n\n\t\tborder: {\n\t\t\t...options,\n\t\t\tweight: lineWeight,\n\t\t\trenderer,\n\t\t\tfill: false\n\t\t}\n\t};\n}\n\nexport function generatePolylineStyles(options: HighlightableLayerOptions<PathOptions>, renderer: Renderer): Record<string, PathOptions> {\n\tconst isBright = getBrightness(options.color!.replace(/^#/, \"\")) > 0.7\n\tconst outlineColor = options.outlineColor ?? (\n\t\tisBright ? \"#000000\" : \"#ffffff\"\n\t);\n\n\t// A black outline makes the lines look thicker, thus we decrease the thickness to make them look the original size again.\n\t// If the user has specified a custom look for the outline, let's not do any magic.\n\tconst lineWeight = (options.outlineColor == null && options.outlineWeight == null && isBright) ? Math.round(options.weight! / 1.6) : options.weight!;\n\n\tconst outlineWeight = options.outlineWeight ?? (lineWeight * 2);\n\n\treturn {\n\t\toutline: {\n\t\t\t...options,\n\t\t\tcolor: outlineColor,\n\t\t\tweight: outlineWeight,\n\t\t\trenderer\n\t\t},\n\n\t\tline: {\n\t\t\t...options,\n\t\t\tweight: lineWeight,\n\t\t\trenderer\n\t\t},\n\n\t\tmain: {\n\t\t\topacity: 0,\n\t\t\tweight: Math.max(POLYLINE_MIN_INTERACTION_WIDTH, outlineWeight, lineWeight),\n\t\t\tpane: \"lhl-almost-over\",\n\t\t\tdashArray: undefined,\n\t\t\tdashOffset: undefined\n\t\t}\n\t};\n}","import { Circle, CircleMarker, CircleMarkerOptions, Map, Path, PathOptions, Polygon, Polyline, PolylineOptions, Rectangle, Renderer } from \"leaflet\";\nimport { setLayerPane, setLayerRenderer } from \"./panes\";\nimport { generatePolygonStyles, generatePolylineStyles } from \"./styles\";\nimport { clone } from \"./utils\";\n\nexport type HighlightableLayerOptions<O extends PathOptions> = O & {\n\traised?: boolean;\n\toutlineColor?: string;\n\toutlineWeight?: number;\n\tgenerateStyles?: (options: HighlightableLayerOptions<O>, renderer: Renderer) => Record<string, O>;\n};\n\nexport type HighlightableLayer<\n\tT extends Path,\n\tO extends PathOptions\n> = T & {\n\trealOptions: HighlightableLayerOptions<O>;\n\tlayers: Record<string, T>;\n\tgenerateStyles(options: HighlightableLayerOptions<O>, renderer: Renderer): Record<string, O>;\n\tsetStyle(style: Partial<HighlightableLayerOptions<O>>): HighlightableLayer<T, O>;\n};\n\nexport function createHighlightableLayerClass<\n\tB extends new (...args: any[]) => Path,\n\tT extends InstanceType<B>,\n\tO extends PathOptions\n>(\n\tBaseClass: B,\n\tcreateLayer: (mainLayer: HighlightableLayer<T, O>) => InstanceType<B>,\n\tcloneMethods: Array<keyof T> = [],\n\tdefaultOptions?: HighlightableLayerOptions<O>\n): new (arg1: ConstructorParameters<B>[0], options?: HighlightableLayerOptions<O>) => HighlightableLayer<T, O> {\n\tconst result = class HighlightableLayer extends BaseClass {\n\t\tdeclare options: O;\n\t\trealOptions: HighlightableLayerOptions<O>;\n\t\tlayers: Record<string, InstanceType<B>> = {};\n\t\t_isAdding = false;\n\n\t\tconstructor(...args: any[]) {\n\t\t\tsuper(...args);\n\n\t\t\tthis.realOptions = Object.assign(Object.create(Object.getPrototypeOf(this.options)), {\n\t\t\t\tgenerateStyles: generatePolygonStyles,\n\t\t\t\t...defaultOptions,\n\t\t\t\t...this.options\n\t\t\t});\n\t\t}\n\n\t\tbeforeAdd(map: Map) {\n\t\t\t// Use a custom renderer for each layer so that it creates an additional element that we can set an opacity on\n\t\t\tconst renderer = map._createRenderer();\n\n\t\t\tthis._updateStyle(renderer);\n\n\t\t\tthis._renderer = renderer;\n\t\t\trenderer.once(\"add\", () => {\n\t\t\t\trenderer._container.style.opacity = `${this.realOptions.opacity ?? 1}`;\n\t\t\t});\n\t\t\tmap.addLayer(renderer);\n\n\t\t\treturn this;\n\t\t}\n\n\t\tonAdd(map: Map) {\n\t\t\tsuper.onAdd(map);\n\n\t\t\tfor (const layerName of Object.keys(this.layers)) {\n\t\t\t\tmap.addLayer(this.layers[layerName]);\n\t\t\t}\n\n\t\t\treturn this as any;\n\t\t}\n\n\t\tonRemove(map: Map) {\n\t\t\tfor (const layerName of Object.keys(this.layers)) {\n\t\t\t\tmap.removeLayer(this.layers[layerName]);\n\t\t\t}\n\n\t\t\tsuper.onRemove(map);\n\n\t\t\tmap.removeLayer(this._renderer!);\n\t\t\tdelete this._renderer;\n\n\t\t\treturn this as any;\n\t\t}\n\n\t\t_updateStyle(renderer: Renderer) {\n\t\t\trenderer.options.pane = this.realOptions.raised ? \"lhl-raised\" : this.realOptions.pane;\n\t\t\tif (renderer._container)\n\t\t\t\trenderer.getPane()!.appendChild(renderer._container); // Move renderer to right pane\n\n\t\t\tconst styles = this.realOptions.generateStyles?.(Object.assign(clone(this.realOptions), { opacity: 1 }), renderer) ?? { main: clone(this.realOptions) }\n\n\t\t\tfor (const layerName of Object.keys(this.layers)) {\n\t\t\t\tif (!Object.prototype.hasOwnProperty.call(styles, layerName)) {\n\t\t\t\t\tif (this._map) {\n\t\t\t\t\t\tthis._map.removeLayer(this.layers[layerName]);\n\t\t\t\t\t}\n\t\t\t\t\tdelete this.layers[layerName];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const layerName of Object.keys(styles)) {\n\t\t\t\tif (layerName !== \"main\") {\n\t\t\t\t\tif (!this.layers[layerName]) {\n\t\t\t\t\t\tthis.layers[layerName] = createLayer(this as any);\n\t\t\t\t\t\tthis.layers[layerName].options.interactive = false;\n\n\t\t\t\t\t\t// Workaround to avoid error when calling setStyle() on Polyline without points\n\t\t\t\t\t\tif (BaseClass === Polyline as any || BaseClass.prototype instanceof Polyline) {\n\t\t\t\t\t\t\tthis.layers[layerName]._updateBounds = function(this: Polyline) {\n\t\t\t\t\t\t\t\tif (this._rawPxBounds)\n\t\t\t\t\t\t\t\t\tBaseClass.prototype._updateBounds.call(this);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (styles.main.pane)\n\t\t\t\tsetLayerPane(this, styles.main.pane);\n\t\t\tif (styles.main.renderer)\n\t\t\t\tsetLayerRenderer(this, styles.main.renderer);\n\n\t\t\tsuper.setStyle(styles.main);\n\n\t\t\tfor (const layerName of Object.keys(this.layers)) {\n\t\t\t\tif (styles[layerName].pane)\n\t\t\t\t\tsetLayerPane(this.layers[layerName], styles[layerName].pane!);\n\t\t\t\tif (styles[layerName].renderer)\n\t\t\t\t\tsetLayerRenderer(this.layers[layerName], styles[layerName].renderer!);\n\n\t\t\t\tthis.layers[layerName].setStyle(styles[layerName]);\n\t\t\t}\n\n\t\t\tif (renderer._container)\n\t\t\t\trenderer._container.style.opacity = `${this.realOptions.opacity ?? 1}`;\n\n\t\t\tif (this._map) {\n\t\t\t\tfor (const layer of Object.values(this.layers)) {\n\t\t\t\t\tif (!layer[\"_map\"]) {\n\t\t\t\t\t\tthis._map.addLayer(layer);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsetStyle(style: Partial<HighlightableLayerOptions<O>>) {\n\t\t\tObject.assign(this.realOptions, style);\n\t\t\tif (this._renderer) {\n\t\t\t\tthis._updateStyle(this._renderer);\n\t\t\t}\n\t\t\treturn this as any;\n\t\t}\n\n\t\t_updateBounds(): void {\n\t\t\t// Workaround to avoid error when calling setStyle() on Polyline without points\n\t\t\tif (!(this instanceof Polyline) || this._rawPxBounds)\n\t\t\t\tsuper._updateBounds();\n\t\t}\n\t} as any;\n\n\tfor (const method of ['redraw', ...cloneMethods]) {\n\t\tresult.prototype[method] = function(...args: any[]): any {\n\t\t\tconst r = Object.getPrototypeOf(result.prototype)[method].apply(this, args);\n\t\t\tfor (const layerName of Object.keys(this.layers)) {\n\t\t\t\tthis.layers[layerName][method].apply(this.layers[layerName], args);\n\t\t\t}\n\t\t\treturn r;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nexport const HighlightableCircle = createHighlightableLayerClass<typeof Circle, Circle, CircleMarkerOptions>(\n\tCircle,\n\t(mainLayer) => new Circle(mainLayer.getLatLng(), mainLayer.getRadius()),\n\t['setRadius', 'setLatLng']\n);\n\nexport const HighlightableCircleMarker = createHighlightableLayerClass<typeof CircleMarker, CircleMarker, CircleMarkerOptions>(\n\tCircleMarker,\n\t(mainLayer) => new CircleMarker(mainLayer.getLatLng(), { radius: mainLayer.getRadius() }),\n\t['setRadius', 'setLatLng']\n);\n\nexport const HighlightablePolygon = createHighlightableLayerClass<typeof Polygon, Polygon, PolylineOptions>(\n\tPolygon,\n\t(mainLayer) => new Polygon(mainLayer.getLatLngs()),\n\t['setLatLngs']\n);\n\nexport const HighlightablePolyline = createHighlightableLayerClass<typeof Polyline, Polyline, PolylineOptions>(\n\tPolyline,\n\t(mainLayer) => new Polyline(mainLayer.getLatLngs() as any),\n\t['setLatLngs'],\n\t{\n\t\tgenerateStyles: generatePolylineStyles\n\t}\n);\n\nexport const HighlightableRectangle = createHighlightableLayerClass<typeof Rectangle, Rectangle, PolylineOptions>(\n\tRectangle,\n\t(mainLayer) => new Rectangle(mainLayer.getBounds()),\n\t['setBounds']\n);"],"names":["isBright"],"mappings":"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"}